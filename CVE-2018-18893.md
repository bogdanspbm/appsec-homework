**CVE-2018-18893 (Маджуга Богдан Андреевич)**

**Описание:**

Выполняем данный код используя **Jinjava** версия <= 2.4.5

```
Jinjava jinjava = new Jinjava();
JinjavaInterpreter interpreter = jinjava.newInterpreter(); 
Context context = interpreter.getContext(); context.put("obj",""); 
String poc ="''.getClass().forName(\"java.lang.Runtime\").getMethod(\"exec\",''.getClass()).invoke(''.getClass().forName(\"java.lang.Runtime\").getMethod(\"getRuntime\").invoke(null),'/usr/bin/gnome-calculator')"; 
Object a = interpreter.resolveELExpression(poc, -1);
```

После запуска - на Linux машине запускается приложение калькулятор. 

Данная уязвимость отсылается к типу **Expression Resolver** уязвимостям и вообще говоря, для нее не предусмотрен конкретный набор методов, вызывающих ее. В процессе анализа уязвимости и кода, было замечено, что исходная строка конвертируется в метод, который вызывается системой. Следовательно необходимо было искать объекты абстрактного Java класса `Method` и вызов у них методов под названием `invoke()`

Первичным осмотром, искомый код нашелся в классе **BeanELResolver**, где нас интересует следующий код:

```
  @Override
  public Object invoke(
    ELContext context,
    Object base,
    Object method,
    Class<?>[] paramTypes,
    Object[] params
  ) {
    if (context == null) {
      throw new NullPointerException();
    }
    Object result = null;
    if (isResolvable(base)) {
      if (params == null) {
        params = new Object[0];
      }
      String name = method.toString();
      Method target = findMethod(base, name, paramTypes, params, params.length);
      if (target == null) {
        throw new MethodNotFoundException(
          "Cannot find method " +
          name +
          " with " +
          params.length +
          " parameters in " +
          base.getClass()
        );
      }
      try {
        result =
          target.invoke(
            base,
            coerceParams(getExpressionFactory(context), target, params)
          );
      } catch (InvocationTargetException e) {
        throw new ELException(e.getCause());
      } catch (IllegalAccessException e) {
        throw new ELException(e);
      }
      context.setPropertyResolved(true);
    }
    return result;
  }
```
```
  protected Method findMethod(
    Object base,
    String name,
    Class<?>[] types,
    Object[] params,
    int paramCount
  ) {
    if (types != null) {
      try {
        return findAccessibleMethod(base.getClass().getMethod(name, types));
      } catch (NoSuchMethodException e) {
        return null;
      }
    }
    Method varArgsMethod = null;
    for (Method method : base.getClass().getMethods()) {
      if (method.getName().equals(name)) {
        int formalParamCount = method.getParameterTypes().length;
        if (method.isVarArgs() && paramCount >= formalParamCount - 1) {
          varArgsMethod = method;
        } else if (paramCount == formalParamCount) {
          return findAccessibleMethod(method);
        }
      }
    }
    return varArgsMethod == null ? null : findAccessibleMethod(varArgsMethod);
  }
```

**Semgrep**

Для начала, запустим стандартный набор правил `semgrep ci` и посмотрим, что нам выдаст общий анализ. Входе анализа была выявленна ровно одна уязвимость с использованием данного правила:

```
rules:
  - id: el-injection
    metadata:
      cwe:
        - "CWE-94: Improper Control of Generation of Code ('Code Injection')"
      owasp:
        - A03:2021 - Injection
      source-rule-url: https://find-sec-bugs.github.io/bugs.htm#EL_INJECTION
      category: security
      technology:
        - java
      references:
        - https://owasp.org/Top10/A03_2021-Injection
      cwe2022-top25: true
      subcategory:
        - audit
      likelihood: LOW
      impact: HIGH
      confidence: LOW
      license: Commons Clause License Condition v1.0[LGPL-2.1-only]
      vulnerability_class:
        - Code Injection
    message: An expression is built with a dynamic value. The source of the value(s)
      should be verified to avoid that unfiltered values fall into this risky
      code evaluation.
    severity: WARNING
    languages:
      - java
    patterns:
      - pattern-either:
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createValueExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF = ...;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createValueExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              $X $METHOD(...) {
                ...
                ExpressionFactory $EF = ...;
                ...
                $EF.createValueExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(...,ExpressionFactory $EF,...) {
                ...
                $EF.createValueExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createMethodExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              class $CLASS {
                ...
                ExpressionFactory $EF = ...;
                ...
                $X $METHOD(...) {
                  ...
                  $EF.createMethodExpression($CTX,$INPUT,...);
                  ...
                }
                ...
              }
          - pattern: |
              $X $METHOD(...) {
                ...
                ExpressionFactory $EF = ...;
                ...
                $EF.createMethodExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(...,ExpressionFactory $EF,...) {
                ...
                $EF.createMethodExpression($CTX,$INPUT,...);
                ...
              }
          - pattern: |
              $X $METHOD(String $INPUT, ...) {
                ...
                $OBJECT.buildConstraintViolationWithTemplate($INPUT, ...);
                ...
              }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $EF.createValueExpression($CTX,"...",...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $EF.createValueExpression($CTX,$S,...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            $EF.createMethodExpression($CTX,"...",...);
            ...
          }
      - pattern-not: |
          $X $METHOD(...) {
            ...
            String $S = "...";
            ...
            $EF.createMethodExpression($CTX,$S,...);
            ...
          }
```

Описание уязвимости:
**Уязвимость:** el-injection
**Класс:** ExpressionResolver 

Данная уязвимость непосредственно связанна с искомой, но находит она её на слишком высоком уровне. Соотвественно было написанно новое правило, для поиска строчки - приводящей к уязвимости:

```
rules:
  - id: find-method-invoke
    languages:
      - java
    patterns:
      - pattern: (java.lang.reflect.Method $METHOD).invoke(...);
    message: "Found method invocation: {{source}}"
    severity: WARNING
```

Стоит отметить, что данное правило достаточно абстрактное, но оно находит проблемное место в коде.



**CodeQL**
**Joern**
importCode(inputPath="./jinjava", projectName="jinjava")
